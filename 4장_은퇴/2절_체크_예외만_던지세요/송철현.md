# 체크 예외만 던지세요
## 내용 정리

---
1. 꼭 필요한 경우가 아니라면 예외를 잡지 마세요 <br>

* 가능하면 예외를 더 높은 레벨로 전파

* 반드시 예외를 잡아야 하는 이유가 있거나 다른 선택의 여지가 없는 경우가 아니라면 예외를 잡지 마라

* 예외를 잡아 상황을 '구조'하는 일은 매우 정당한 이유가 있을 경우에만 용인되는 매우 중요한 행동임 <br>
=> 이 상황은 앞 챕터에서 설명한 `안전하게 실패하기` 사고 방식과 같음 <br>

2. 항상 예외를 체이닝하세요 <br>

* `빠르게 실패하기`와 유사

```java
public int length(File file) throws Exception {
    try {
        return content(file).length();
    }catch(IOException ex) {
        throw new Exception("길이를 계산할 수 없다.", ex);
    }
}
```

* 예외를 잡은 즉시 새로운 예외를 던짐 <br>
=> '예외 체이닝(exception chaning)'은 훌륭한 프랙티스 <br>
=> 원래의 문제를 새로운 문제로 대체함으로써 문제가 발생햇따는 사실을 무시하지 않음 <br>

* 문제를 발생시켰던 낮은 수준의 근본 원인(root cause)을 소프트웨어의 더 높은 수준으로 이동시킴


```java
/**
* 근본 원인을 무시하는 좋지 않은 방법
*/
public int length(File file) throws Exception {
    try {
        return content(file).length();
    }catch(IOException ex) {
        // 여기에서는 문제 'ex'를 무시하고,
        // 새로운 메시지를 가지는 새로운 타입의 새로운 문제를
        // 생성한다.
        throw new Exception("계산할 수 없다.");
    }
}
```

* 문제를 발생시킨 근본 원인에 관한 매우 가치있는 정보가 손실되기 때문에 매우 나쁜 프랙티스 <br>
=> 문제를 발생시킨 근본 원인: '너무 낳은 열린 파일(24)'과 같은 메시지 <br>
=> 이 예외를 무시하고 '계산할 수 없다'는 메시지를 담고 잇는 새로운 예외를 생성 <br>

* 예외 체이닝은 의미론적으로 문제와 관련된 문맥을 풍부하게 만들기 위해 필요함 <br>
=> '열린 파일이 너무 많음(24)'이라는 메시지만으로는 정보를 전달하는데 충분하지 않음, 이 메세지의 수준은 너무 낮음 <br>
=> 대신 여러 예외들을 내부에 담고 있는 일련의 예외 체인을 사용하는 편이 좋음 <br>
  - 열린 파일이 너무 많음 -> 파일의 길이를 계산할 수 없음 -> 이미지 내용을 읽을 수 없음 : 형식으로 예외 체이닝을 진행

✔️ 항상 예외를 체이닝하고 절대로 원래 예외를 무시하지 마라

3. 단 한번만 복구하세요

* 빠르게 실패하기와 안전하게 실패하기 사이의 충돌을 다른 각도에서 바라본 것뿐임 <br>
=> 빠르게 실패하기에서는 복구라는 개념 자체가 존재하지 않음 <br>
=> 예외 후 복구는 '흐름 제어를 위한 예외 사용(using exceptions for flow control)'으로 알려진 안티패턴의 또 다른 이름일 뿐임 <br>

```java
// 이 코드는 앞에 챕터에서 설명했던 NULL을 반환하는 안티패턴과 유사
int age;

try {
    age = Integer.parseInt(text);
}catch(NumberFormatException ex) {
    // 여기에서 발생한 예외를 '복구'한다
    age = -1;
}
```

* 무조건 예외를 잡아서는 안된다는 주장이 아님, 딱 한번은 복구해야 함 <br>
=> 항상 예외를 잡고, 체이닝하고, 다지 던지자 <br>
=> 예외를 잡아야 한다면 가장 최상위 수준에서 오직 한번만 복구 <br>
  - Java에서는 정적 메서드 main 부분에서 잡음

4. 관점-지향 프로그래밍을 사용하세요

* 가끔씩은 실패한 오퍼레이션을 재시도할 필요가 있음 <br>
=> HTTP 요청을 전송해서 웹 페이지를 다운로드하는 경우를 가정 <br>
=> 오류가 날 경우 매번 사용자에게 오류 메시지를 표시하고 애플리케이션을 재실행하라고 요청할 수 없음 <br>

* 이럴때는 `관점-지향 프로그래밍(aspect -oriented programming, AOP)`이라는 기법을 이용하자

5. 하나의 예외 타입만으로도 충분합니다

* 단 한번만 복구한다면 어떤 예외라도 담을 수 있는 예외 객체만 있으면 됨 <br>
=> 올바르게 예외를 체이닝했다면 예외의 타입을 알아야 할 이유가 있을까?

* 예외를 사용할 일이 없기 때문에 예외의 타입 정보는 필요하지 않음, 예외가 상위로 전파되는 도중에는 예외를 잡을 일이 없음. 예외를 잡을 때 조차도, 오직 한 가지 목적을 위해서만 잡아야 함.

* 그것은 바로 예외를 체이닝한 후 다시 던지기 위해서임

<br>

## 느낀점
---

고민 하던 주제 중 하나가 예외 처리를 어떻게 하는게 좋은지여서 재미있는 챕터였다. 일하고 있는 곳은 try-catch로 오류를 잡아 단순히 로그 정보만 출력하고 끝낸다. 빠르게 실패하기나 안전하게 실패하기도 아닌 오류를 무시한..... <br>

개발을 하면서 아니다 싶었지만 어떻게 처리하는게 좋을지 몰랐는데 많은 부분을 깨달았다. 예외 타입 정보는 필요하지 않다라고 나와있어 살짝 의아하기는 하지만, 이 참에 나만의 정의를 가져야겠다.

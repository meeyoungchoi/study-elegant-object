언체크 예외를 사용하는 것은 실수이며, 모든 예외는 체크 예외여야 한다. 또한 다양한 예외 타입을 만든느 것도 좋지 않다.

# 체크예외

```java
public byte[] content(File file) throws IOException {
	byte[] array = new byte[1000];
	new FileInputStream(file).read(array);
	return array;
}
```

IOException을 상위로 던지기 떄문에 무슨일이 있어도 호출하는 쪽에서 해당 예외를 잡아야한다. (**책임을 넘긴다.**)

**이 방법은 ‘안전'하지 않다. → 해당 예외 때문에 비정상적으로 종료 될 수 있기 때문이다.**

해당 메서드를 호출하는 곳에서 또 책임을 클라이언트로 전파하면서(escalating) 본인이 ‘안전하지 않다'고 또 선언한다면 계속 예외를 상위로 ‘띄워 올린다.’

`IOException`은 `catch`구문을 통해 반드시 잡아야 하기 때문에 ‘체크(checked) 예외' 에 속한다. 예외를 잡거나 상위로 전파하기 위해 `throws IOException` 을 **메서드 시그니처에 선언해야 하는데 이 때문에 체크 예외는 항상 가시적이다.**

# 언체크 예외

**무시할 수 있으며 예외를 잡지 않아도 무방하다.**

누군가 예외를 잡기 전까지 자동으로 상위로 전파되나, 언어는 예외처리를 강요하지 않는다.

```java
public int length(File file) throws IOException {
	if(!file.exists()) {
		throw new IllegalArgumentException(
			"File doesn't exist; I can't count its length."
		);
	}
	return content(file).length();
}
```

해당 메서드 시그니처에서 IllegalArgumentException에 대한 정보는 숨겨져 있다. 어떤 예외가 던져질 수 알 수 없다.

**언체크 예외의 경우 예외의 타입을 선언하지 않아도 무방한 반면, 체크예외는 항상 예외의 타입을 공개해야 한다.**

# 4.2.1 꼭 필요한 경우가 아니라면 예외를 잡지 마세요

메서드를 설계할 때 모든 예외를 잡아서 메서드를' 안전하게' 만들지, 아니면 상위로 ‘문제를 전파’할지를 명확하게 선택해야 한다.

저자는 상위로 전파하는 방법을 선호한다. **가능하면 예외를 더 높은레벨로 전파하라고 한다. 반드시 예외를 잡아야하거나 다른 선택의 여지가 없는 경우가 아니라면 예외를 잡아선 안된다.**

이상적인 설계로는 애플리케이션의 각 진입점 별로 오직 하나의 catch 문만 존재해야 한다.

```java
public int length(File file) {
	try {
		return content(file).length();
	} catch (IOException ex) {
		return 0;
	}
}
```

위 `length()` 메서드는 매우 안전하다. 어떤일이 발생해도 메서드는 종료되지 않는다.

하지만 이 메서드는 문제를 은폐해버린다. 결국 클라이언트를 포함한 모든 이들에게 매우 안좋은 품질의 서비스를 제공하게 된다.

→ 언젠간 애플리케이션이 비정상적으로 종료될 수 밖에 없지만 아주 멀리 떨어진 곳에서 시스템이 종료되어 찾기 힘들다.

**이런 접근 방법을 ‘흐름 제어를 위한 예외 사용' 이라고 부른다.**

```java
public int length(File file) {
	if(/* 파일 시스템에 문제가 있으면 */) {
		return 0;
	} else {
		return content(file).length();
	}
}
```

예외는 분기를 위한 도구가 아니다.  예외는 복구 불가능한 상황을 나타내기 위해 설계됐다.

```java
int length = length(new File("test.txt"));

if(length == -1) {
	printf("뭔가 잘못됨");
} else {
	print("파일 사이즈는 %d다." + length);
}
```

이 코드에서 문제가 되는 부분은 `==` 연산자를 사용하여 반환값과 -1을 비교하는것이다.

이와 같은 비교는 메서드가 반환하는 length 객체를 신뢰하지 않는다는 신호이며, 문제의 원인을 파악하기 매우 어려워진다.

**예외를 잡아 상황을 ‘구조'하는 일은 정당한 이유가 있을 경우에만 용인된다. ‘잡아서 로깅하기’는 말하지 않아도 끔찍한 안티패턴이다.**

# 4.2.2 항상 예외를 체이닝하세요

```java
public int length(File file) throws Exception {
	try {
		return content(file).length();
	} catch (IOException ex) {
		throw new Exception("길이를 계산할 수 없다.", ex);
	}
}
```

‘예외 되던지기'의 올바른 사용 예이다. **이와 같은 예외 체이닝(exception chaining)은 훌륭한 예제이다.**

**원래의 문제를 새로운 문제로 감싸서 함께 상위로 던진다.**

문제의 비눗방울 안에는 많은 계층이 존재할 수 있고, 그 문제를 해결하기 위해 무엇을 할 지를 결정하는 마지막 catch문이 비눗방울을 터뜨린후 그 안에 포함된 비눗방울을 꺼낸다.

다음 코드처럼 근본 원인을 무시하는 것은 좋은 생각이 아니다.

```java
public int length(File file) throws Exception {
	try {
		return content(file).length();
	} catch (IOException ex) {
		// 여기에선 문제 ex를 무시하고 새로운 메시지를 가지는 새로운 타입의 새로운 문제를 생성.
		throw new Exception("계산할 수 없다.");
	}
}
```

내부의 root 문제가 보이지 않게 되어 문제를 찾는데 큰 시간이 소요될 수 있다.

**이상적으로 각각의 메서드는 발생할 수 있는 모든 예외를 잡은 후, 예외를 체이닝하여 다시 던져야 한다.**

# 4.2.3 단 한번만 복구하세요

빠르게 실패하기에서는 복구라는 개념 자체가 존재하지 않는다.

예외 후 복구는 ‘흐름 제어를 위한 예외 사용'으로 알려진 안티패턴의 또 다른 이름이다.

```java
int age;
try {
	age = Integer.parseInt(text);
} catch (NumberFormatException ex) {
	// 여기에서 발생한 예외를 '복구'한다.
	age = -1;
}
```

NULL을 반환하는 안티패턴과 유사하다. 하지만 무조건 예외를 잡아서는 안된다는 주장은 옳지 않다.

**딱 한번은 복구해도 된다.**

main 메서드는 애플리케이션의 가장 높은곳에 위치해 있는데 여기서 예외를 잡지 않는다면 런타임 환경으로 예외가 전달되고 **결국 JVM이 예외를 잡게된다.**

이때 사용자는 해당 메시지를 보지만 **해당 메시지는 사용자 친화적이지 않을 것**이다. 스택 트레이스 전체가 노출될 것인데 이런일은 있으면 안된다. **최상위 수준에서 오직 한번만 ‘복구' 하자.**

# 4.2.4 관점-지향 프로그래밍을 사용하세요

가끔씩은 실패한 오퍼레이션을 재시도 할 필요가 있다. 하지만 최상위 수준에 이르기 전에 예외를 복구하는 것은 이때까지의 내용과 모순된다.

한가지 해결방법은 AOP를 사용하는 것이다.

# 4.2.5 하나의 예외 타입만으로도 충분합니다.

**사실 단 한번만 복구한다면 어떤 예외라도 담을 수 있는 예외 객체만 있으면 된다.**

예외를 사용할 일이 없기 때문에 예외의 타입 정보는 필요하지 않는다. 예외가 상위로 전파되는 도중에는 예외를 잡을 일이 없다. 예외를 잡을 때 조차도, 오직 한가지 목적을 위해서만 잡아야 한다. 그것은 바로 예외를  체이닝 한 후 다시 던지기 위해서이다.

---

# 느낀점

언체크 예외와 체크 예외에 대한 새로운 정의를 이 책을 통해서 깨달았다;

어떤 블로그 글이던, 책이던 언체크와 체크를 이런 개념으로 설명해주는 곳은 없는듯. 이제야 정확히 구분할 수 있게 됐다.
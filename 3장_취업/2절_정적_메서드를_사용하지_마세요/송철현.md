# 정적 메서드를 사용하지 마세요

## 내용 정리

---
1. 객체 대 컴퓨터 사고(object vs. computer thinking) <br>

```c
int max(int a, int b) {
    if(a > b) {
        return a;
    }

    return b;
}
```

* 컴퓨터는 제공된 명령어를 하나씩 순차적으로 실행: `순차적인(sequential) 사고 방식`

* 우리가 결정하고, 컴퓨터는 따르고, 스크립트의 위에서 아래로 흐름

* CPU에게 할 일을 지시하는 것이 아니라 `정의`함

* 컴퓨터처럼 생각하기에서는 명령의 실행 흐름을 제어할 책임이 우리에게 있음

* 정적 메서드는 OOP와 아무런 상관이 없음, 객체지향 언어의 문법을 이용해서 절차적인 코드를 작성하도록 부추김

* 올바른 객체지향 설계에서는 정적 메서드를 사용해서는 안 됨

<br>

---
2. 선언형 스타일 대 명령형 스타일(declarative vs. imperative style)

* 명령형 프로그래밍(imperative programming)에서는 '프로그램의 상태를 변경하는 문장(statement)을 사용해서 계산 방식을 `서술`'

* 선언형 프로그래밍(declarative programing)에서는 '제어 흐름을 서술하지 않고 계산 로직을 `표현`'

* 명령형 프로그래밍은 컴퓨터처럼 연산을 차례대로 실행 <br>
=> 메서드를 호출한 시점에 CPU가 즉시 결과를 계산

* 선언현 프로그래밍은 우리가 000는 `무엇인지만` 정의하고, 계산하는 시점은 000를 사용하는 사용자가 결정, 아예 실행되지 않을 수도 있음 <br>
=> 우리는 선언만하고 CPU에게 어떤 일을 하라고 지시하지 않음, 제어를 서술하지 않고 로직만 표현

✔️ 선언형 프로그래밍의 장점

* 빠름: 우리가 직접 성능 최적화를 제어할 수 있기 때문 <br>
=> 실행 관점에서 선언형 방식이 더 `최적화`되기 때문에 더 빠르다는 말 <br>
=> 최적화 관점에서 직접 통제할 수 있는 코드가 많을수록 유지보수하기도 더 쉬워짐 <br>

* 다형성: 코드 블록 사이의 의존성을 끊을 수 있는 능력 <br>
=> 객체를 다른 모든 객체로부터 완전히 분리하기 위해서는 어떤 메서드나 주 ctor 안에서도 new 연산자를 사용해서은 안됨

* 표현력 <br>
=> 선언형 방식은 결과를 이야기하는데 반해, 명령형 방식은 수행 가능한 한 가지 방법을 이야기 함 <br>
=> 명령형 방식에서 결과를 예쌍하기 위해서는 먼저 머릿속에서 코드를 '실행'해야하기 때문에 명령형 방식이 선언형 방식보다 덜 직관적 <br>
=> 명령형 스타일이 `알고리즘과 실행을 다루는 방법`이라면, 선언형 스타일은 정확하게 `객체와 행동`에 관한 방법임

* 응집도

<br>

---
3. 유틸리티 클래스(Utility classes)

* 다른 메서드들이 사용하는 정적 메서드들을 모아 놓은 정적 메서드들의 컬렉션, 다른 말로는 '헬퍼(helper)'

* 유틸리티 클래스는 끔직한 안티 패턴

<br>

---
4. 싱글톤(Singleton) 패턴

* 유명한 '디자인 패턴'이지만, 사실 끔직한 안티 패턴

* 싱글톤과 유틸리티 클래스의 차이점으로 '싱글톤은 상태를 유지'한다는 말은 `틀린 말` <br>
=> 싱글톤의 목적은 상태를 유지하는 것이 아님

* 두 개의 가장 큰 차이는 `싱글톤은 분리 가능한 의존성으로 연결되어 있는데 반해, 유틸리티 클래스는 분리가 불가능한 하드코딩된 결합도를 가진 것`

* 캡슐화된 객체를 변경할 수 있기 때문에 싱글톤이 유틸리티 클래스보다는 더 좋다는 것 <br>
=> 더 낫다는 말이지 좋다는 말이 아님, 둘 다 안티 패턴 <br>
=> 둘 다 사용하지 않고 캡슐화(encapsulation)를 사용하자

<br>

---
5. 함수형 프로그래밍

* 객체의 크기가 작고, 상태가 변하지 않으며 정적 메서드도 포함하지 않는다면, 함수형 프로그래밍(functional programming, FP)을 활용하는 편이 더 낫지 않느냐는 질문을 종종 받음

* FP보다 OOP의 표현력이 더 뛰어나고 강력하기 때문

* FP를 향한 움직임의 일환으로 도입된 Java의 람다 표현식(Lambda Expression)은 진정한 객체지향 스타일로부터 우리를 멀어지게 만들기 때문에 Java의 견고함을 약화 시킴


<br>

---
6. 조합 가능한 데코레이터

* '조합 가능한 데코레이터(composable decorator)'는 공식적으로 사용되는 명칭이 아니라 저자가 새로 고안한 용어

* 데코레이터는 다른 객체를 감싸는 객체

* 객체지향 프로그래밍이란 더 작은 객체들을 기반으로 더 큰 객체들을 조합하는 작업
 <br>
 => 정적 메서드는 조합이 불가능 <br>
 => OOP에서 정적 메서드를 사용해서는 안되는 또 다른 이유 <br>

* 조합 가능한 데코레이터 <br>
=> 객체들의 전체적인 행동은 내부에 캡슐화하고 있는 객체들에 의 유도됨 <br>
=> 각 데코레이터는 내부에 캡슐화하고 있는 객체에 별도의 행동을 추구 <br>
=> 데코레이터의 상태는 내부에 캡슐화하고 있는 객체들의 상태와 동일함

<br>

## 느낀점
---

이번화도 저자가 조금 강하게 객체지향 찬양론을 펼치기에 이해보다는 거부감이 들었다. 전전 챕터에서는 객체지향스럽지 않은 방법에 대한 이야기를 하지 않았....나!? 😅😅 <br>

개인적으로 static의 문제점을 인식하고 주의해서 사용하면 되겠다로 결론 내렸다. 또, 유틸리티 클래스를 사용하지 말라는 말은 요즘 들어서 동의하고 있다. 생각해보면 이건 절차지향적인 방식이 아니던가? <br>

편리하다는 이유로 별 고민 없이 사용했던 나를 반성한다. 객체지향...어렵다;;;

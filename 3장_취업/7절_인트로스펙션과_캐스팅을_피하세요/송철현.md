# 인트로스펙션과 캐스팅을 피하세요
## 내용 정리

---
1. 리플렉션(reflection) <br>

* 타입 인트로스펙션은 리플랙션이라는 더 포괄적인 용어로 불리는 여러 가지 기법들 중 하나

* 리플렉션을 사용하면 메서드, 명령어, 구문, 클래스, 객체, 타입 등을 변경할 수 있음 <br>
=> CPU가 이 요소들에 접근하기 전에 쉽고 간단하게 코드를 수정할 수 있음 <br>
=> 리플렉션은 매우 강력한 기법이지만 동시에 코드를 유지보수하기 어렵게 만드는 매우 너저분한 기법 <br>
=> 코드가 런타임에 다른 코드에 의해 수정된다는 사실을 항상 기억해야 함 <br>


```java
/**
* Iterable의 크기를 계산하는 메서드
* 메서드는 먼저 size() 메서드를 정의하고 있는 Collection의 인스턴스인지 확인
* 사용하기에 매우 편리하고 성능 관점에서도 최적화된 것처럼 보이지만, 매우 잘못된 방식
*/
public <T> int size(Iterable<T> items) {
    if(items instanceof COllection) {
        return Collection.class.cast(items).size();
    }

    int size = 0;
    for(T item : items) {
        ++size;
    }
    return size;
}
```

* 타입에 따라 객체를 `차별하기 때문에` OOP의 기본 사상을 심각하게 훼손 <br>
=> 코드는 items 객체의 타입에 따라 서로 다른 방식으로 객체와 상호작용 <br>
=> 요청을 어떤 식으로 처리할 지 객체가 결정할 수 있도록 하는 대신, 객체를 배재한 상태에서 결정을 내리고, 이를 바탕으로 좋은 객체와 나쁜 객체를 차별 <br>

* 런타임에 객체의 타입을 조사(introspect)하는 것은 클래스 사이의 결합도가 높아지기 때문에 기술적인 관점에서도 좋지 않음 <br>
=> 위 코드에서 size() 메서드는 Iterable과 Collection이라는 두 개의 인터페이스에 의존 <br>
=> 의존하는 대상이 늘어날수록 결합도가 높아지고 유지보수성의 측면에서 좋지 않음 <br>
=> 또, 의존성이 숨겨져 있다는 면에서 유지보수성에 커다란 악영향을 끼침 <br>

```java
/* 좋은 방법: 메서드 오버로딩(method overloading) */
public <T> int size(Collection<T> items) {
    return items.size();
}

public <T> int size(Iterable<T> items) {
    int size = 0;
    for(T item : items) {
        ++size;
    }
    return size;
}
```


✔️ 클래스 캐스팅(class casting)에도 동일하게 적용

* 결합도가 숨겨져 있기 때문에 좋지 않은 방법

* 클라이언트와 객체 사이의 불명확하고, 은폐되고, 암시적인 관계는 유지보수성에 심각한 영향을 끼침

> 정리하면, instaceof 연산자를 사용하거나 클래스를 캐스팅하는 일은 안티패턴으로 사용하지 말자

<br>

## 느낀점
---

instanceof 연산자가 객체지향 관점에서 좋지 않다는 글이 많다. 생각해보면 instanceof는 잘못하면 많은 수의 if문을 만든다. 또, 타입마다 다른 로직이 생긴다면 SRP를 위반하게 될 수 있다. 이외에도 여러 문제가 있을거다. <br>

음... 클래스 캐스팅은 생각치 못했다. 결합도를 숨긴다는데 맞는것 같다. 근데 많이 보이는 레거시 코드인데... 이렇게 또 한번 좌절한다. 생각해보니 볼때마다 이해하려고 고생을 했다. <br>

클래스 캐스팅에 대한 건 더 찾아봐야겠다.

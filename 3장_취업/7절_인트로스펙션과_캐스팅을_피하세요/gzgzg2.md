# 3.7 인트로스펙션과 캐스팅을 피하세요

## 정리

### 1. 리플렉션은 나쁜 프로그래머에게 유용한 강력한 기법

- instanceof 연산자와 Class.cast() 메서드는 런타임에 객체의 타입을 확인하기 때문에 결합도가 강해진다.
- 리플렉션은 매우 강력한 기법이지만 런타임에 다른 코드에의해 수정된다는 사실을 항상 기억해야하기 때문에 코드를 읽기 어려워지고 유지보수가 힘들어진다.
- 타입에 따라 객체를 차별하는 것은 OOP의 기본 사상을 훼손하는 행동이다.

<br>


**나쁜 예시**

```java
public <T> int size(Iterable<T> items) {
	if(items instanceof Collection) {
		return Collection.class.cast(items).size();
	}
	int size = 0;
	for (T item : items) {
			++ size;
	}
	return size; 
}
```

위와 같은 코드는 런타임에 타입을 확인하기 때문에 좋지않은 방식이다.  런타임에 타입을 확인하기 때문에 결합도가 증가하고 타입에 따라 객체를 차별하기 때문에 객체 스스로 행동을 결정할 수 없게 된다. 

더 나아가서 size() 메서드는 Collection과 Iterable이라는 두 개의 인터페이스에 의존하고 있는 것이다. 실제로 사용자는 메서드 내부에서 타입을 조사한다는 사실을 알지 못하기 때문에 유지보수에 큰 악영향을 끼친다. 

<br>

**좋은 예시**

```java
public <T> omt size(Collection<T> items) {
	return items.size();
}

public <T> int size(Iterable<T> items) {
	int size = 0;
	for (T item : items) {
		++size;
	}
	return size;
}
```

메서드 오버로딩 기법을 사용하여 해결한 예제이다. 이 경우에는 사용자가 어떤 메서드를 호출할지 결정하기 때문에 인트로스펙션과 타입 캐스팅을 사용한 메서드보다 유지보수가 쉽고 의존이 분리되었기 때문에 낮은 결합도를 가진다. 

<br>

### 2. 클래스 캐스팅을 멀리하세요

- 클래스 캐스팅은 사전에 약속하지 않았던 새로운 계약을 따르도록 강제한다.
- 직업으로 예를 들면 배관공에게 컴퓨터 수리를 부탁하는 셈이다.

<br>


```java
return Collection.class.cast(items).size();

return ((Collection) items).size(); 
```

기술적으로 두 코드는 동일하게 동작한다. 하지만 위 코드는 배관공에게 “저는 당신이 컴퓨터 전문가라고 가정하고 있습니다. 그러니 이 컴퓨터를 수리해주세요” 라고 이야기하는 것과 비슷하다. 

<br>


```java
if (items instanceof Collection) {
	return ((Collocetion) items).size(); 
}
```

앞서 소개한 코드보다 완결된 예제이기는 하나, Collection과의 결합도가 숨겨져 있다.  현실세계로 예를 들자면 새로운 배관공을 파견하려고 할 때 회사는 배관공에게 프린터 수리에 추가 금액을 지불한다는 사실을 기억하고 있기 때문에 배관공인 동시에 컴퓨터 전문가인 사람을 찾으려고 시도하는 것이다. 

나중에 수도배관회사를 바꾸려고 할 때 싱크대와 프린터를 함께 수리해야할 수 있는 사람을 다시 요청해야한다. 하지만 이 사실은 계약서 어디도 문서화 되어있지 않을 것이다. 

<br>


### 3. 결론

클래스 캐스팅과 인트로스펙션은 방문한 객체에 대한 `기대(expection)` 를 문서에 명시적으로 기록하지 않은 채로 외부에 노출한 것과 같다. 사용자마다 코드 작성자의 기대하는 바를 **학습(learn)** 하여 작성자의 의도대로 사용하는 것이 각자 다를 것이다. 이는 클라이언트와 객체 사이의 불명확하고 은폐되고 암시적인 관계를 만든다. 암시적인 관계는 유지보수성에 심각한 영향을 끼친다. 

<br>

## 느낀점

 앞으로 타입에 따라 기능이 분기되는 조건이 있으면 오버로딩을 사용하면 될 것 같다. 그리고 런타임에 타입을 확인하는 코드는 결합도도 문제이지만 안정성이 매우 떨어질 것 같다고 느꼈다.

그런데 실제로 자주 사용하는 라이브러리 중에 리플렉션을 사용한 라이브러리가 꽤 있는 것으로 아는데,, 대표적으로 롬복이라던지 .. 롬복은 너무 편한 라이브러리여서 이러한 기능을 제공할 수 있게 해주는 리플렉션이 무조건 나쁜 것인지는 잘 모르겠다. 물론 리플렉션을 남발한 코드는 좋지 않다고 생각되지만 .. 

역시 편한 것은 독인 것 같다.

앞쪽 섹션에서 모든 클래스는 불변이어야 한다고 설명했다. 하지만 get과 set을 쓰는 순간 가변이 되어버린다.

# 3.5.1 객체 대 자료구조

## 예시

### 자료구조(C)

```cpp
struct Cash {
	int dollars;
}
```

### 객체(C++)

```cpp
#include <string>
class Cash {
	public:
		Cash(int v): dollars(v) {};
		std::string print() const;
	private:
		int dollars;
};
```

위 자료구조와 객체를 사용하는 방식에서 차이점이 보일것이다.

```cpp
//자료구조(c)
print("Cash value is %d", cash.dollars);

//자료구조(c++)
print("Cash value is %d", cash.print());
```

- 자료구조
    - 멤버인 dollars에 직접 접근 후 값을 정수로 취급한다.
    - struct와는 아무런 의사소통도 없이 직접적으로 멤버에 접근하며, 단순한 데이터 가방이 된다.
    - 투명하다. (Glass Box)
    - 수동적이다. (죽어있다.)
- 클래스
    - 멤버에게 접근하는 것을 허용하지 않는다.
    - 멤버를 노출하지 않는다. (캡슐화)
    - print()가 어떤 방식으로 동작하는지도 알수 없고 어떤 멤버가 이 작업에 개입하는지 알 수 없다.
    - 불투명하다. (Black box)
    - 능동적이다. (살아있다.)

**모든 프로그래밍 스타일의 핵심 목표는 가시성의 범위를 축소해서 사물을 단순화 시키는 것**이다. 특정 시점에 이해해야 하는 범위가 작을수록 유지보수성이 향상되고 이해와 수정이 쉬워진다.

**OOP는 코드가 데이터를 지배하지 않는다. 필요한 시점에 객체가 자신의 코드를 실행시킨다.** 객체가 일급 시민이고 생성자를 통한 객체 초기화가 곧 소프트웨어이며, 소프트웨어는 생성자를 통해 구성된다.

## 객체지향을 위해선

- 데이터를 객체안에 감추고 외부로 노출시키면 안된다.

# 3.5.2 좋은 의도, 나쁜 결과

getter와 setter는 캡슐화 원칙을 위반하기 위해 설계되었다.

자바에선 프로퍼티를 public으로 바꾸면 기본 규칙을 위반하게 되기 때문에 프로퍼티를 private로 만들고 getter와 setter를 추가시켰다.

하지만 이 getter와 setter를 사용하면 OOP의 캡슐화 원칙을 손쉽게 위반할 수 있다. 결국 **행동이 아닌 데이터를 표현할 뿐인 메서드이기 때문**이다.

# 3.5.3 접두사에 관한 모든 것

getter/setter 안티패턴에서 유해한 부분은 두 접두사인 ‘get’과 ‘set’이다.

`dollar()` 라는 메서드를 통해 `value` 를 반환하는 것은 괜찮지만 `getDollar()` 라는 메서드 이름을 짓는건 적절하지 않다.

두 메서드의 뉘앙스는 다르다.

- getDollars()
    
    → 데이터 중에 dollars를 찾은 후 반환하세요. (데이터의 저장소로 취급, 데이터 노출)
    
- dollars()
    
    → 얼마나 많은 달러가 필요한가요? (객체 존중, 데이터 미노출)
    

**절대로 getter와 setter방식으로 메서드 이름을 짓지 말아라.**

---

# 느낀점

동감하는 얘기뿐.

대신 자료구조와 클래스에 대한 차이점을 확실히 보여주며 해당 부분이 getter와 setter를 피해야 한다는 주장에 뒷받침이 되는 부분이 너무 좋았다. 쓰지 말란건 알고있었지만 이러한 정확한 근거 (자료구조로의 회귀) 가 좋은 예시였다고 생각한다.

또한 setter는 무조건적으로 지양했지만 getter는 사실.. 많이 쓰고있었다. 반성…
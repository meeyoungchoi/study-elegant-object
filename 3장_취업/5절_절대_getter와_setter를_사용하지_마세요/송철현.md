# 절대 getter와 setter를 사용하지 마세요

## 내용 정리

---
1. 객체 대 자료구조 <br>

* struct(구조체)의 경우, 어떤 '개성(personality)'도 지니지 않은 단순한 데이터 가방(data bag)일 뿐임 <br>
=> 아무런 의사소통도 하지 않고 직접적으로 멤버에 접근 <br>

* 클래스는 어떤 식으로든 멤버에게 접근하는 것을 허용하지 않음 <br>
=> 추가적으로 자신의 멤버를 노출하지도 않음 <br>
=> 클래스 안에 어떤 멤버가 있는지조차 알 수 없음 <br>
=> 우리는 객체에게 자기 자신을 print()하라고 용처하는 것 뿐임, 실제로 어떤 방식으로 동작하는 지도 알 수  없음
=> 이것이 `캡슐화(encapsulation)`이며, OOP가 지향하는 가장 중요한 설계 원칙 중 하나

* 자료구조는 투명하지만, 객체는 불투명

* 자료구조는 글래스 박스(glass box)이지만, 객체는 블랙 박스(black box)

* 자료구조는 수동적이지만, 객체는 능동적

* 자료구조는 죽어있지만, 객체는 살아 있음

✔️ 객체와 자료구조를 동시에 가질 수는 없는 걸까? 유지보수성을 위해 `안됨`

(1) 절자척 프로그래밍이든, 함수형 프로그래밍이든, 객체지향 프로그래밍이든, 모든 프로그래밍 스타일의 핵심 목표는 가시성의 범위를 `축소`해서 사물을 `단순화시키는` 것 <br>
=> 특정한 시점에 이해해야 하는 범위가 작을수록, 소프트웨어의 유지보수성이 향상되고 이해하고 수정하기 쉬워짐 <br>

(2) 절차적인 프로그래밍과 명령형 프로그래밍은 서브루틴과 데이터 집합(data aggregate)을 사용하여 가시성의 범위를 축소하고 사물을 단순화 시킴 <br>

(3) 객체지향 프로그래밍은 데이터를 객체 안에 캡슐화하고 메세지로 요청해서 작업을 실행 <br>
=> 객체를 작게 만들고 데이터를 캡슐화하는 등 객체의 자율성을 보장, 이를 통해 가시성의 범위를 축소하고 사물을 단순화 시킴 <br>

<br>

---
2. 좋은 의도, 나쁜 결과

* 근본적으로 getter와 setter는 캡슐화 원칙을 `위반하기` 위해 설계되었음

* 저자의 요점은 getter와 setter를 사용하면 OOP의 캡슐화 원칙을 손쉽게 위반할 수 있다는 말 <br>
=> 겉으로는 메서드처럼 보이지만, 실제로는 우리가 데이터에 직접 접근하고 있음, 데이터는 무방비로 노출되어 있는 것과 같음 <br>
=> getter와 setter는 내부 구현과 무관하게 이들은 데이터일 뿐임, 행동이 아닌 데이터를 표현할 뿐임 <br>

<br>

---
3. 접두사에 관한 모든 것

* 두 접두사인 get과 set은 이 객체가 진짜 객체가 아니고, 어떤 존중도 받을 가치가 없는 자료구조라는 사실을 명확하게 전달 <br>

* get과 set을 통해 데이터가 표면에 완전히 드러나 있으며, 클래스의 모든 사용자는 이 데이터를 볼 수 있음


<br>

## 느낀점
---
get과 set은 오랜시간 헷갈리고 고민했던 부분이라 쓰지 않아야 한다는 것에 동의한다. 지금은 IDE나 Lombok으로 쉽게 get과 set을 만들 수 있다. 내가 경계하는 부분은 너무 쉽게 만들 수 있다는 거다. <br>

작업을 하다보면 get과 set을 써서 데이터를 가공하고 처리하는게 개발이 빠르다. 시간이 지나 다시보면 get과 set으로 인해 객체간에 결합도가 증가하는 코드가 많이 생겨나 있었다. 결국 빠르게 작성하려다보니 절차지향적으로 프로그래밍하게 되었다. <br>

그런 의미에서 get과 set은 주의해서 써야한다고 생각한다. 내가 생각하기에는 get은 최종적으로 사용자에게 보여주어야할 데이터가 필요하기에 어느정도 허용할 필요는 있다고 생각한다. 하지만, set의 경우 안 쓰는 것이 좋다고 본다.

# 3.3 인자의 값으로 NULL을 절대 허용하지 마세요

NULL은 커다란 골칫거리중 하나다.

# 객체를 존중하도록 처리

NULL을 사용하면 각각의 객체가 자신의 행동을 온전히 책임진다는 객체 패러다임과는 상반되게 된다.

왜냐면 내부 메서드에서 `if` 문을 통해 NULL인지 확인하는(`object == null`) 분기문이 필요하기 때문이다.

이것은 **해당 객체에게 이야기하는 대신 객체를 피하고 무시하게 된다.**

**객체를 존중하기 위해선 조건의 존재여부를 객체 스스로 결정하게 한다.**

(ex) object.empty(), object.matches(file)…

# NULL을 비허용하자

허용하게 되면 결국 `==` 같은 비교문을 사용할 수 밖에 없다. 즉, 실체를 확인하는 것 말고는 답이 없기 때문에 NULL을 허용시키지 말자.

# NULL의 과거

예전부터 지켜온 약속이다. CPU는 `0x00000000`의 주소값에 절대로 접근하지 않기로 합의했다. 이러한 이유로 **포인터의 값이 0인 경우는 NULL이라고 부르기로 규약을 맺었다.**

이젠 대부분의 언어들이 포인터를 제공하지 않지만 객체지향에서도 이 ‘개념'을 물려받고 말았다.

이것은 커다란 실수라고 저자는 생각한다.

# 안전한 사용법

전달할 것이 없다면 비어있는 것처럼 행동하는 객체를 전달하자.

전달받은 인자가 객체인지 NULL인지를 확인하는 일을 구현자에게 떠넘겨선 안된다. 항상 객체를 전달하되 전달한 객체에게 무리한 요청을 한다면 응답을 거부하도록 하자.

```java
interface Mask {
	boolean matches(File file);	
}

class AnyFile implements Mask {
	@Override
	boolean matches(File file) {
		return true;
	}
}
```

위와 같이 객체를 만들어 NULL값의 전달 대신 AnyFile의 인스턴스를 생성하여 find() 메서드에 전달해도 된다.

# 어거지로 보내는 NULL 대처법

1. 방어적인 방법
    - 내부에서 NULL을 체크한 후 예외를 던진다
        - (ex) if(object == null) {}
2. 무시하는 방법
    - NULL이 아니라고 가정하고 어떤 대비도 하지 않는.
        - (ex) NPE 발생

저자는 2번 방법을 선호한다. **중요하지 않은 NULL 확인 로직으로 코드를 오염시켜선 안된다는 것**이다.

---

# 느낀점

이번 장은 특히나 객체를 하나의 생명체처럼 대하는 느낌이 강했다.

NULL을 넘기는 방식은 정말 지양해야한다. 동감한다.
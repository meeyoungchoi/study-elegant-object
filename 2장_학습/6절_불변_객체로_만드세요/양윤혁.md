> 정리
> 

- 불변 객체 : 인스턴스를 생성한 후에 상태를 변경할 수 없는 객체를 의미한다.
- 모든 클래스를 상태 변경이 불가능한 불변 클래스로 구현하면 응집력이 높고 느슨하게 결합되어 유지보수하기 쉬운 클래스를 만들 수 있어 코드 이해가 쉽고 유지보수성도 높다.
- 가변 객체는 존재해서는 안된다.

1. 가변 객체 (상태 변경이 가능하다.)

```
class Cash{
private int dollars;

    public void setDollars(int val) {
		this.dollars = val;
	}
}
```

1. 불변 객체 (상태를 변경할 수 없다.)

```
class Cash{
private final int dollars;

  Cash(int val) {
	this.dollars = val;
	}
}
```

### 식별자 가변성

```
Map<Cash, String>map = new HashMap<>();
Cash five = new Cash("$5");
Cash ten = new Cash("$10");
map.put(five,"five");
map.put(ten,"ten");
five.mul(2); // mul : 해당 인자와 초기화된 멤버변수의 곱을 해당 멤버변수로 다시 초기화하는 함수
System.out.println(map); // {$10="five", $10=>"ten"}
```

- 불변 객체를 사용하면 객체를 map에 추가한 후에는 상태 변경이 불가능하기 때문에 “식별자 가변성”문제가 발생하지 않는다.
- HashMap은 불변 객체의 상태를 기반으로 해시 코드를 계산하고 이 값을 해시 테이블에 저장한 후에는 값을 그대로 유지한다.
- 따라서 불변 객체를 사용하면 식별자 가변성 문제를 완벽하게 제거할 수 있다.

### 실패 원자성

- 실패 원자성이란 완전하고 견고한 상태의 객체를 가지거나 아니면 실패하거나 둘 중 하나만 가능한 특성이다.
- 불변 객체의 정의에 따르면 모든 불변 객체는 원자적이기 때문에 원자성을 걱정할 필요가 없다.
- 가변 객체 내에서 실패 원자성을 보장하는 방법이 좋지 않은 이유는 객체의 복잡성이 훨씬 높아지고 이 때문에 실수할 가능성이 커지기 때문이다.

```
class Cash{
private int dollars;
    private int cents;

    public void mul(int factor){
int before = this.dollars;
        this.dollars *= factor;
        if(/* cents와 관련해서 뭔가 잘못됐다면 */){
this.dollars = before;
            throw new RuntimeException("oops..");
}
this.cents *= factor;
}
}
```

Cash 클래스에서는 예외를 던지기 직전에 this.dollars의 값을 임시 변수에 저장해서 값을 복수할 수 있게 되어 있다.

현재 Cash 클래스 규모가 작아 큰일은 아니나, 객체의 크기가 점점 커지면 복구해야 할 프로퍼티가 누락될 수 있기 마련이다. 

### 시간적 결합

다음의 예제를 살펴보면 가변 객체를 인스턴스화하고 초기화하는 과정에서 

시간적 순서에 따라 결합되있는걸 확인할 수 있다. 

```
Cash price = new Cash();
price.setDollars(29);
price.setCents(95);
System.out.println(price); // "$29.95"
```

허나, 다음과 같이 불변 객체를 이용하면 코드 순서 배열을 해야하는 개발자의 수고를 덜 수 있습니다. 

이로 인해 코드 전반적으로 구문 사이에 존재하는 시간적인 결합을 제거할 수 있습니다. 

```
Cash price = new Cash(29.95);
System.out.println(price); // "$29.95"
```

### 부수효과 제거

- 특정 클래스를 불변으로 만들면 어느 누구도 객체를 수정할 수 없습니다.
- 이로 인해 특정 실수가 발생해도 해당 클래스 내 객체의 값이 손상 받을 일이 없습니다.

### NULL 참조 없애기

- null은 빈 문자열과 크게 다르지 않습니다. null인지 아닌지는 항상 체크해야 합니다.
- 이는 유지보수성과 연관됩니다. 실제 데이터가 아닌 null을 참조하는 객체는 유지보수성 측면에 있어 치명적일 수 밖에 없습니다.
- 모든 객체를 불변으로 만드는 경우 객체 안에 null을 포함시킬 수 없으니, 작고 견고하며 응집도 높은 객체를 생성할 수 밖에 없기에 유지보수적 측면에서 훌륭하다고 볼 수 있습니다.

### 스레드 안정성

- 스레드 안정성이란 글자 그대로 객체가 여러 스레드에서 동시에 사용될 수 있으며 그 결과를 항상 예측 가능하도록 유지할 수 있는 객체의 품질을 의미합니다.
- 계산하는 로직이 포함된 클래스를 여러 스레드에서 동시에 실행할 경우 병행성 이슈가 발생하여 일시적으로 데이터가 변할 수 있습니다. 이러한 이슈는 해결하기 어려운 문제 중 하나입니다.
- 불변 객체는 실행 시점에 상태를 수정할 수 없게 금지함으로써 이 문제를 해결할 수 있습니다.

### 더 작고 더 단순한 객체

- 객체가 단순해질수록 응집도는 높아지며 유지보수하기는 더 쉬워집니다.
- 단순하다는 의미는 적은 코드 줄 수를 의미하며 클래스 내 코드가 짧을수록 리팩토링에 있어 훨씬 수월합니다.
- 단적인 예로 어플리케이션에 포함되어 있는 모든 클래스의 길이를 250줄 이하로 유지한다면 좋은 아키텍트라고 생각해도 무방합니다.
- 불변 객체는 생성자 안에서만 상태를 초기화할 수 있기에 클래스를 더 깔끔하고 짧게 만듭니다.
- 이는 불변 클래스로부터 얻을 수 있는 가장 중요한 장점입니다.

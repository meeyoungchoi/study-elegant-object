# 불변 객체로 만드세요

## 내용 정리

---
1. 불변성 <br>

* 모든 클래스를 상태 변경이 불가능한 불변 클래스(immutable class)로 구현하면 유지보수성을 크게 향상시킬 수 있음 <br>

* 불변성은 크기가 작고, 응집력이 높으며, 느슨하게 결합되고, 유지보수하기 쉬운 클래스를 만들 수 있도록 함 <br>

* 이해하기 쉬운 코드가 유지보수하기도 쉬움 <br>
=> 가변 클래스(mutable class)보다는 불변 클래스를 이해하는 쪽이 훨씬 수월

```java
class Cash {  // 가변 객체
    private int dollars;

    public void setDollars(int val) {  // 해당 메서도르 상태 변경이 가능
        this.dollars = val;
    }
}

// 인스턴스를 생성한 후에 상태를 변경할 수 없는 객체를 불변 객체라고 부름
class Cash {  // 불변 객체
    private final int dollars;

    Cash(int val) {
        this.dollars = val;
    }
}
```

* 불변 객체는 필요한 모든 것을 내부에 캡슐화하고 변경할 수 없도록 통제

* 불변 객체를 수정해야 한다면 프로퍼티를 수정하는 대신 새로운 객체를 생성

* 가변 객체의 사용을 `엄격하게 금지해야 함`

---
✔️ 지연 로딩(lazy loading)을 잠시 살펴보자~

지연 로딩 기법을 사용을 사용하면 객체가 캡슐화하고 있는 프로퍼티를 업데이트할 필요가 있을 때 프로퍼티를 '게으르게(lazily)' 로드할 수 있음

```java
class Page {
    private final String uri;
    private String html;

    Page(String address) {
        this.uri = address;
        this.html = null;
    }

    public String content() {
        if(this.html == null) {
            this.html = /* 네트워크로부터 로드한다 */
        }

        return this.html;
    }
}
```
객체를 생성하는 시점에 this.html 안에는 아무 것도 저장되어 있지 않다. 실제 데이터 대신 null이 할당되어 있는 상태다. content() 메서드를 최초로 호출하는 시점에 저장된다. 다시 content()를 호출하면 이미 저장되어 있는 내용을 반환한다. 이는 가변적이다. <br>

지연 로딩은 `실행 시간을 단축하기 위해서`는 필요하다. 하지만, 불변에서는 이러한 `지연 로딩이 불가능`하다. 객체를 불변으로 유지하면서도 지연 로딩을 구현할 수 있는 다양한 해결방법이 있는데, 우리는 섹션 1.3에서 이 주제를 다뤘으며, 순수한 불변성을 추구하지만 않는다면 유용한 캐싱 메커니즘을 살펴봤다.

---
2. 식별자 가변성(Identity Mutability)

*  두 객체를 비교한 후 한 객체의 상태를 변경할 때 두 객체는 더 이상 동일하지 않지만, 사용자는 여전히 두 객체가 동일하다고 생각함. 아니면 그 반대 일 수도 있음. <br>
=> 불변 객체에는 '식별자 가변성' 문제가 없음

3. 실패 원자성(Failure Atomicity)

* '실패 원자성'이란 완전하고 견고한 상태의 객체를 가지거나 아니면 실패하거나 둘 중 하나만 가능한 특성, 중간은 없음 <br>
=> 가변 객체를 사용하더라도 '실패 원자성'이라는 목표를 달성할 수 있지만, 이를 위해서는 특별한 주의를 기울여야 함, 객체의 복잡성이 훨씬 더 높아지고 그 때문에 실수할 가능성이 더 커짐 <br>
=> 불변 객체를 사용하면 별도의 처리 없이도 원자성을 얻을 수 있음 <br>

---
3. 시간적 결합(Temporal Coupling)

```java
Cash price = new Cash();
price.setDollars(29);
price.setCents(95);
System.out.println(price);  // "$29.95"
```

* 가변 객체를 인스턴스화하고 초기화하는 일반적인 방법 <br>
=> 'setter'를 이용해 프로퍼티 값들을 설정(초기화), 이 방식은 다양한 표준에서 Java 객체를 조작하기 위해 권장하는 방식 <br>
=> 이러한 표준들은 Java 문법을 사용하는 절차적인 프로그래머들의 입장에서는 훌륭한 설계겠지만, 진정한 '객체 사고(object thinking)'의 관점에서는 완전히 잘못된 방식

* 'setter'들의 실행 순서가 그대로 유지되어야함(println 이전에 실행되어야 함)

* 코드와 코드 사이에 `시간적인 결합`을 이해해야 하는데, 이는 전적으로 프로그래머의 몫 <br>
=> 객체들을 처리하는 연산들의 순서를 일일이 기억해야 한다면 `유지보수`가 어려움

* 불변 객체는 인스턴스화와 초기화를 함께하기 때문에 시간적 결합에 대해 신경쓰지 않아도 됨

---
4. 부수효과 제거(Side effect-free)

* 객체가 가변적일 때는 누구든 손쉽게 객체를 수정할 수 있음

* 언제, 어디서, 누가 객체를 수정할 수 있기에 어떤 부수 효과가 발생할지 모르게 되고, 코드를 신뢰할 수 없게 됨

---
5. NULL 참조 없애기

* Java로 프로그래밍하다보면 NULL 체크를 신경써야하는 경우를 경험했을 것

* 모든 객체를 불변으로 만들면 객체 안에 NULL을 포함시키는 것이 애초에 불가능해짐 <br>
=> 작고, 견고하고, 응집도 높은 객체를 생성할 수 밖에 없도록 `강제되기 때문에` 결과적으로 유지보수 하기에 훨씬 더 쉬운 객체를 만듬

---
6. 스레드 안전성(Thread Safety)

* 스레드 안전성이란 여러 스레드에서 동시에(concurrently) 사용될 수 있으며 그 결과를 항상 `예측가능하도록` 유지할 수 있는 객체의 품질을 의미

* 불변 객체는 실행 시점에 상태를 수정할 수 없게 금지함으로써 이 문제를 완벽하게 해결

* 가변 클래스도 스레드에 안전하게 만들 수 있음(명시적인 동기화 이용) <br>
=> 할수는 있지만, 생각처럼 쉽지 않음 <br>
=> 동기화 로직을 추가하는 일은 성능상의 비용을 초래 <br>
=> 각 스레드는 객체를 `배타적으로 잠그기 때문에` 다른 모든 스레드는 객체가 해제될 때까지 기다릴 수 밖에 없음, 또한 데드락이 발생할 수 있음

```java
class Cash {
    private int dollars;
    private int cents;

    public void mul(int factor) {
        synchronized (this) {       // 많은 비용을 초래
            this.dollars *= factor;
            this.cents *= factor;
        }
    }
}
```

---
7. 더 작고 더 단순한 객체

* 불변 객체를 아주 크게 만드는 일은 불가능하기 때문에, 일반적으로 불변 객체는 가변 객체보다 더 작음

* 불변 객체가 작은 이유는 생성자 안에서만 상태를 초기화할 수 있기 때문임

* 처음에 작게 만큰 객체가 시간이 흐르면서 기능이 추가되고 그에 따라 객체의 크기가 커짐, 생성자 역시 증가하게됨, 이는 문제를 인식하게만들고 더 작은 클래스로 분리하게 만듬 <br>
=> `불변 클래스는 생성자로 초기화를 강제하기 때문에 문제를 인식하기 쉬움`



## 느낀점
---
불변성은 요즘 많이 듣고 있어 시간을 내서 고민하려고 했던 주제중에 하나다. 기억으로는 불변성이 자주 언급되기 시작한 것은 함수형 패러다임이 나온 이후다(정확한 사실은 아니다...모른다...🙈🙈🙈) <br>

객체지향 패러다임은 변경 가능한 상태를 객체 안에 숨기고(캡슐화) 객체 스스로가 상태를 관리하는 `책임`을 가지도록 만드는 것으로 안다. 'getter', 'setter'를 남발하지 말라는 말도 외부에 상태 노출을 최소하기 위한 것이다. <br>

함수형 패러다임은 공부하지 않았기에 언급하지 않겠다...🙈 다만, 객체지향 패러다임에서 가변성을 완전히 배제할 수는 없다고 생각한다. 애초에 객체지향 패러다임은 그게 아니지 않는가? 🤔 <br>

개인적으로 정리하면 두 관점을 서로 배제하지 말고 적절하게 쓰는게 좋은 것 같다. 'setter'를 없애고 생성자로 초기화를 하는 방법은 좋다고 생각한다. <br>

아...쓰다보니... 객체지향 패러다임과 책에서 말하는 불병성의 중요성은 다른 내용인가? 모르겠다... 더 고민해봐야지....🙈🙈🙈

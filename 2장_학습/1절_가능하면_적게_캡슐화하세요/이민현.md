# 모든 것은 유지보수성과 관련이 있다.

이 책에서 조언하는 모든 것은 직접적으로 코드의 복잡성에 영향을 미치고, 복잡성은 유지보수성에 영향을 미친다.

# 상태없는 객체는 존재해선 안되고, 상태는 객체의 식별자여야 한다.

4개 또는 혹은 그 이하의 객체를 캡슐화 할 것을 권장한다. 더 많은 객체를 캡슐화해야 한다면 클래스에 문제가 있는 것이기 때문에 리팩토링이 필요하다.

‘객체'는 고수준의 행동을 낳기 위해 함께 동작하는 객체들의 집합체(Aggregation)이다.

다른 객체를 캡슐화 하지 않는 객체(부품이 없는 객체)란 존재할 수 없지만 Java에서는 가능하다. 게다가 내부가 동일함에도 다른 객체라고 판단하는데 이것은 잘못된 방식이다.

**상태없는 객체는 존재해선 안되고, 상태는 객체의 식별자여야 한다.**

# 왜 4개가 적합한가?

객체의 식별자는 기본적으로 세계 안에서 객체가 위치하는 좌표이다.

객체를 바라보는 우리의 사고방식은 4개 이상의 요소로 구성된 좌표를 이해하는 것이 어렵다. 

물론 실세계의 하나의 객체는 컴퓨터 속의 객체보다 훨씬 복잡하다. 하지만 이 속성들은 객체를 이용해 다시 그룹화 될 수 있기 때문에 결과적으로 전체 속성들은 객체들로 구성된 트리를 구성하게 된다.

물론 수십개의 객체를 캡슐화 하고 있는 클래스도 있지만 잘못된 것이다. 더 많은 객체가 필요하다면 클래스를 더 작은 클래스들로 분해해야 한다.

그리고 Java에서는 꼭 `equals()` 메서드를 오버라이드 하라.

---

# 느낀점

맞는말이긴한데.. 처음 읽었을 때부터 느꼈던 거지만 책 자체가 너무 강압적이고 이상향만을 바라본다.

하지만 이런 부분을 통해서 책을 읽는 독자가 유연하게 가져간다면 좋을것 같다.

이번 챕터도 사실 맞는말이다. 예를 들어 자동차라는 객체를 만들때 본인은 `carName` 이라는 클래스를 만들어 쪼갠다. 정말 잘게잘게.. 그리고 carName과 관련된 도메인 로직을 해당 객체에서 진행하도록 한다.

하지만 4개는 너무 적은듯..ㅠ 너무 사소한것까지 객체화 시키는게 정말 맞는걸까 사실 고민이 많이 된다. 만드는 내입장에선 괜찮지만 다른 사람이 코드를 봤을때 너무나 파편화 되어있다고 생각을 하던 경험이 있어서..

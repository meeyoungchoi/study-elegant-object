# 소프트웨어 모듈이 가져야 하는 세가지 기능

- `모듈` - 클래스 , 패키지 , 라이브러리와 같이 프로그램을 구성하는 임의의 요소

## 소프트웨어 모듈의 목적

1. 실행 중에 제대로 동작해야 한다
2. 변경을 위해 존재한다 - 모듈은 생명주기 동안 변경되기 때문에 간단한 작업 만으로도 변경이 가능해야 한다
3. 특별한 훈련이 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다

## 예상을 빗나가는 코드

- Theater클래스의 enter 메서드가 수행하는 역할
- 소극장이 관람객 가방에 초대장을 갖고 있는지 검사
    - 있으면 판매원이 매표소의 티켓을 관람객의 가방 안으로 넣는다
    - 없으면 관람객이 티켓 비용을 지불하고 판매원이 티켓을 가방 안으로 넣는다
- 관람객과 판매원이 소극장의 통제를 받은 수동적인 존재 이다
- 왜?
- 관람객의 입장에서 소극장이라는 제3자가 초대장을 확인하기 위해 관람객의 가방을 마음대로 열어 본다
- 소극장이 판매원의 허락없이 매표소에 보관중인 티켓과 현금에 마음대로 접근한다
- 티켓을 꺼내 관람객의 가방에 집어넣고 관람객에게서 받은 돈을 매표소에 적립하는 일을 소극장이 수행한다

```jsx
public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().minusAmount(ticket.getFee());
            ticketSeller.getTicketOffice().plusMoney(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
}
```

- 현실에서는
- 관람객이 직접 가방에서 초대장을 꺼내 판매원에게 건낸다
- 티켓을 구매하는 관람객은 가방 안에서 돈을 직접 꺼내 판매원에게 지불한다
- 판매원은 매표소에 있는 티켓을 직접 껀내 관람객에게 건네고 고나람객에게서 직접 돈을 받아 매표소에 보관한다
- 하자민 위의 코드는 그렇게 설계되 있지 않다

## 문제점 2

- enter 메서드를 이해하기 위해서는 세부적인 내용들을 기억하고 있어야 한다
- Audience가 Bag을 가지고 있고
- Bag 안에는 현금과 티켓이 들어 있으며
- TicketSeller가 TicketOffice에서 티켓을 판매하고
- TicketOffice 안에 돈과 티켓이 보관돼 있다는 사실을 동시에 기억하고 있어야 한다
- 하나의 메서드에서 너무 많은 세부사항을 다루기 때문에 코드를 작성하는 사람뿐 아니라 코드를 읽고 이해해야 하는 사람 모두에게 부담을 준다

## 문제점 3

- Audience와 TicketSeller를 변경할 경우 Theater도 함께 변경해야 한다

## 변경에 취약한 코드

- enter 메서드는 관람객이 현금과 초대장을 보관하기 위해 가방을 항상 갖고 다녀야 한다고 가정한다
- 판매원이 매표소에서만 티켓을 판매한다고 가정한다
- 관객이 가방을 들고 있지 않다면 어떻게 해야 할가?
- 관람객이 현금이 아닌 신용카드를 사용하여 결제를 한다면 어떻게 해야 할까?
- 판매원이 매표소 밖에서 티켓을 판매해야 한담녀 어떻게 해야 할까?
- 가정이 깨지는 순간 코드가 흔들리게 된다

### 관람객이 가방을 들고 있다는 가정이 바뀐다면

- Audience 클래스에서 Bag을 제거해야 한다
- Theater 클래스의 enter 메서드도 수정해야 한다
- 왜?
- 관람객이 가방을 들고 있고 판매원이 매표소에서만 티켓을 판매한다는 사실에 세부적인 사실에 의존해서 동작하기 때문
- 세부적인 사실중 한 가지라도 바뀌면 해당 클래스 뿐만 아니라 클래스에 의존하는 Theater도 함께 변경해야 한다
- 즉 , 다른 클래스가 Audience 내부에 대해 더 많이 알면 알수록 Audience를 변경하기 어려워 진다

### 객체 사이의 의존성

- 의존성은 변경과 관련되 있다
- 의존성은 어떤 객체가 변경될 때 그 객체에 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포되 있다

### 객체 사이의 의존성을 완전히 없애야 하는가

- 아니다
- 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다
- 애플리케이션의 기능을 구현하는데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거해야 한다

### 너무 많은 클래스에 의존하는 Theater

- 객체 사이에 의존서잉 과한 경우를 결합도가 높다고 말한다
- 객체들이 합리적인 수준으로 의존할 경우에는 결합도가 낫다고 말한다
- 결합도는 의존성과 관련되 있으므로 변경과도 관련이 있다
- 두 객체 사이의 결합도가 높으면 함께 변경될 확률도 높아지기 때문에 변경하기 어려워진다


### 설계의 목표

- 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만들어야 한다

### 느낀점

- 도메인 모델을 바탕으로 클래스를 설계할때 결합도를 낮춰 변경이 용이하게 설계해야 겠다
